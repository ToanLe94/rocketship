package stats

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"sync"
	"time"

	"github.com/amoghe/distillog"
	"github.com/jinzhu/gorm"
	"github.com/zenazn/goji/web"
)

const (
	URLPrefix = "/stats"

	ECpu        = URLPrefix + "/cpu"
	EMemoryFree = URLPrefix + "/memory/free"

	PrometheusConfPath = "/opt/prometheus/prometheus.yml"
)

type Controller struct {
	db   *gorm.DB
	mux  *web.Mux
	log  distillog.Logger
	lock sync.Mutex
}

func NewController(db *gorm.DB, logger distillog.Logger) *Controller {
	ctrl := &Controller{db: db, mux: web.New(), log: logger}

	ctrl.mux.Get(ECpu+"/:cpu_id", ctrl.GetCPUStats)
	ctrl.mux.Get(EMemoryFree, ctrl.GetMemFreeStats)

	return ctrl
}

// ServeHTTP satisfies the http.Handler interface (net/http as well as goji)
func (c *Controller) ServeHTTPC(ctx web.C, w http.ResponseWriter, r *http.Request) {
	c.lock.Lock()
	c.mux.ServeHTTPC(ctx, w, r)
	c.lock.Unlock()
	return
}

// RoutePrefix returns the URL prefix under which this controller serves its routes
func (c *Controller) RoutePrefix() string {
	return URLPrefix
}

// RewriteFiles regenerates all the config files this controller is responsible for.
func (c *Controller) RewriteFiles() error {
	if err := c.RewritePrometheusFile(); err != nil {
		return err
	}
	return nil
}

// Rewrite default prometheus conf file
func (c *Controller) RewritePrometheusFile() error {
	c.log.Infoln("Rewriting graphite defaults file")

	contents, err := c.prometheusFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(PrometheusConfPath, contents, 0644)
	if err != nil {
		return err
	}

	return nil
}

func (c *Controller) prometheusFileContents() ([]byte, error) {

	conf := `
# Prometheus config (generated by commander)
scrape_configs:
  - job_name: "node"
    scrape_interval: "15s"
    target_groups:
    - targets: ['localhost:9100']
`
	return []byte(conf), nil
}

func (c *Controller) SeedDB() {
	return
}

func (c *Controller) MigrateDB() {
	return
}

//
// Handlers
//

func (c *Controller) GetCPUStats(ctx web.C, w http.ResponseWriter, r *http.Request) {
	var (
		statName string
		duration time.Duration
	)

	duration, err := parseDurationFromContext(ctx)
	if err != nil {
		jsonError(err, w)
		return
	}

	if cpu, there := ctx.URLParams["cpu_id"]; there {
		if id, err := strconv.Atoi(cpu); err != nil {
			jsonError(fmt.Errorf("Invalid CPU ID"), w)
			return
		} else {
			statName = fmt.Sprintf("node_cpu{cpu=\"cpu%d\"}", id)
		}
	}

	samples, err := PrometheusStats(statName, duration)
	if err != nil {
		jsonError(err, w)
		return
	}

	if err := json.NewEncoder(w).Encode(samples); err != nil {
		jsonError(err, w)
	}
}

func (c *Controller) GetMemFreeStats(ctx web.C, w http.ResponseWriter, r *http.Request) {
	var (
		statName = "node_memory_MemFree"
		duration time.Duration
	)

	duration, err := parseDurationFromContext(ctx)
	if err != nil {
		jsonError(err, w)
		return
	}

	samples, err := PrometheusStats(statName, duration)
	if err != nil {
		jsonError(err, w)
		return
	}

	if err := json.NewEncoder(w).Encode(samples); err != nil {
		jsonError(err, w)
	}
}

//
// Helpers
//

func parseDurationFromContext(ctx web.C) (time.Duration, error) {
	var (
		err   error
		there bool
		dur   string
		ret   time.Duration
	)

	if dur, there = ctx.URLParams["duration"]; !there {
		return ret, fmt.Errorf("Missing duration parameter")
	}
	if len(dur) <= 0 {
		return ret, fmt.Errorf("Missing duration parameter")
	}
	if ret, err = time.ParseDuration(dur); err != nil {
		return ret, err
	}
	return ret, nil
}

func jsonError(err error, w http.ResponseWriter) {
	resp := struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	}

	json.NewEncoder(w).Encode(resp)
}
