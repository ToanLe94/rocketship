package dhcp

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/jinzhu/gorm"
	"github.com/zenazn/goji/web"
)

const (
	// Default hostname for the system
	DefaultHostname = "ncc1701"
	DefaultDomain   = ""

	// Endpoint at which the hostname can be configured
	EHostname = "/hostname"
	// Endpoint at which domain can be configured
	EDomain = "/domain"

	InterfacesFilePath = "/etc/network/interfaces"
)

type Controller struct {
	db  *gorm.DB
	mux *web.Mux

	commitChan      chan func() error
	commitErrorChan chan error
}

func NewController(db *gorm.DB,
	commitChan chan func() error,
	commitErrorChan chan error) *Controller {

	c := Controller{
		db:              db,
		mux:             web.New(),
		commitChan:      commitChan,
		commitErrorChan: commitErrorChan,
	}

	c.mux.Get(EHostname, c.GetHostname)
	c.mux.Put(EHostname, c.PutHostname)

	c.mux.Get(EDomain, c.GetDomain)
	c.mux.Put(EDomain, c.PutDomain)

	return &c
}

func (c *Controller) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c.mux.ServeHTTP(w, r)
}

func (c *Controller) MigrateDB() {
	var (
		profile = DHCPProfile{ID: 1}
		iface   = InterfaceConfig{Name: "eth0", Mode: ModeDHCP, DHCPProfileID: 1}
	)

	c.db.AutoMigrate(&Hostname{})
	c.db.AutoMigrate(&Domain{})
	c.db.AutoMigrate(&DHCPProfile{})
	c.db.AutoMigrate(&InterfaceConfig{})

	// Always ensure first entry exists
	c.db.FirstOrCreate(&Hostname{Hostname: DefaultHostname})
	c.db.FirstOrCreate(&Domain{Domain: DefaultDomain})
	c.db.FirstOrCreate(&profile, profile)
	c.db.FirstOrCreate(&iface, iface)
}

//
// Handlers
//

func (c *Controller) GetHostname(w http.ResponseWriter, r *http.Request) {
	host := Hostname{}
	err := c.db.First(&host, 1).Error
	if err != nil {
		c.jsonError(err, w)
		return
	}

	bytes, err := json.Marshal(&host)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	_, err = w.Write(bytes)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	return
}

func (c *Controller) GetDomain(w http.ResponseWriter, r *http.Request) {
	domain := Domain{}
	err := c.db.First(&domain, 1).Error
	if err != nil {
		c.jsonError(err, w)
		return
	}

	bytes, err := json.Marshal(&domain)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	_, err = w.Write(bytes)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	return
}

func (c *Controller) PutHostname(w http.ResponseWriter, r *http.Request) {
	host := Hostname{ID: 1}

	bodybytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	err = json.Unmarshal(bodybytes, &host)
	if err != nil {
		c.jsonError(err, w)
		return
	}
	host.ID = 1

	err = c.db.Save(&host).Error
	if err != nil {
		err = fmt.Errorf("Failed to persist configuration (%s)", err)
		c.jsonError(err, w)
		return
	}

	w.Write(bodybytes)
}

func (c *Controller) PutDomain(w http.ResponseWriter, r *http.Request) {
	domain := Domain{ID: 1}

	bodybytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	err = json.Unmarshal(bodybytes, &domain)
	if err != nil {
		c.jsonError(err, w)
		return
	}
	domain.ID = 1

	err = c.db.Save(&domain).Error
	if err != nil {
		err = fmt.Errorf("Failed to persist configuration (%s)", err)
		c.jsonError(err, w)
		return
	}

	w.Write(bodybytes)
}

//
// AfterCommit
//

func (c *Controller) AfterCommit() error {
	return nil
}

//
// File generators
//

// RewriteHostnameFile rewrites the hostname file.
func (c *Controller) RewriteHostnameFile() error {
	contents, err := c.hostnameFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile("/etc/hostname", contents, 0644)
	if err != nil {
		return err
	}

	return nil
}

// RewriteInterfacesFile rewrites the network interfaces configuration file.
func (c *Controller) RewriteInterfacesFile() error {
	str, err := c.interfacesConfigFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(InterfacesFilePath, []byte(str), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (c *Controller) interfacesConfigFileContents() (string, error) {
	contents := bytes.Buffer{}

	ifaces := []InterfaceConfig{}
	err := c.db.Find(&ifaces).Error
	if err != nil {
		return "", err
	}

	// Banner
	_, _ = contents.WriteString("# This file is AUTOGENERATED.\n")
	_, _ = contents.WriteString("#\n\n")
	// static section for 'lo'
	_, _ = contents.WriteString("auto lo\n")
	_, _ = contents.WriteString("iface lo inet loopback\n\n")

	for _, iface := range ifaces {
		contents.WriteString(c.interfacesConfigFileSection(iface))
		contents.WriteString("\n")
	}

	return contents.String(), nil
}

// returns a section of the interfaces config file that configures the specified nic.
func (c *Controller) interfacesConfigFileSection(iface InterfaceConfig) string {
	contents := bytes.Buffer{}

	// per the docs, err is always nil
	_, _ = contents.WriteString("auto " + iface.Name + "\n")
	_, _ = contents.WriteString("iface " + iface.Name + "inet" + iface.Mode + "\n")
	if iface.Mode == ModeStatic {
		_, _ = contents.WriteString("address " + iface.Address + "\n")
		_, _ = contents.WriteString("netmask " + iface.Netmask + "\n")
		_, _ = contents.WriteString("gateway " + iface.Gateway + "\n")
	}

	return string(contents.Bytes())
}

// returns contents of the hostname file.
func (c *Controller) hostnameFileContents() ([]byte, error) {
	host := Hostname{}

	err := c.db.First(&host, 1).Error
	if err != nil {
		return nil, err
	}

	return []byte(host.Hostname + "\n"), nil
}

//
// Helpers
//

func (c *Controller) jsonError(err error, w http.ResponseWriter) {
	// TODO: switch on err type
	w.WriteHeader(http.StatusInternalServerError)
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(fmt.Sprintf("{\"error\": \"%s\"}", err.Error())))
}
