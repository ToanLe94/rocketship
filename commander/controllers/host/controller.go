package host

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/zenazn/goji/web"
)

const (
	// Endpoint at which the hostname can be configured
	EHostname = "/hostname"
	// Endpoint at which domain can be configured
	EDomain = "/domain"

	InterfacesFilePath   = "/etc/network/interfaces"
	DhclientConfFilePath = "/etc/dhcp/dhclient.conf"
)

type Controller struct {
	db  *gorm.DB
	mux *web.Mux

	commitChan      chan func() error
	commitErrorChan chan error
}

func NewController(db *gorm.DB) *Controller {

	c := Controller{
		db:  db,
		mux: web.New(),
	}

	c.mux.Get(EHostname, c.GetHostname)
	c.mux.Put(EHostname, c.PutHostname)

	c.mux.Get(EDomain, c.GetDomain)
	c.mux.Put(EDomain, c.PutDomain)

	return &c
}

func (c *Controller) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c.mux.ServeHTTP(w, r)
}

func (c *Controller) MigrateDB() {
	var (
		profile = DHCPProfile{ID: 1}
		iface   = InterfaceConfig{Name: "eth0", Mode: ModeDHCP, DHCPProfileID: 1}
	)

	c.db.AutoMigrate(&Hostname{})
	c.db.AutoMigrate(&Domain{})
	c.db.AutoMigrate(&DHCPProfile{})
	c.db.AutoMigrate(&InterfaceConfig{})

	// Always ensure first entry exists
	c.db.FirstOrCreate(&Hostname{Hostname: DefaultHostname})
	c.db.FirstOrCreate(&Domain{Domain: DefaultDomain})
	c.db.FirstOrCreate(&profile, profile)
	c.db.FirstOrCreate(&iface, iface)
}

//
// Handlers
//

func (c *Controller) GetHostname(w http.ResponseWriter, r *http.Request) {
	host := Hostname{}
	err := c.db.First(&host, 1).Error
	if err != nil {
		c.jsonError(err, w)
		return
	}

	bytes, err := json.Marshal(&host)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	_, err = w.Write(bytes)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	return
}

func (c *Controller) GetDomain(w http.ResponseWriter, r *http.Request) {
	domain := Domain{}
	err := c.db.First(&domain, 1).Error
	if err != nil {
		c.jsonError(err, w)
		return
	}

	bytes, err := json.Marshal(&domain)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	_, err = w.Write(bytes)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	return
}

func (c *Controller) PutHostname(w http.ResponseWriter, r *http.Request) {
	host := Hostname{ID: 1}

	bodybytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	err = json.Unmarshal(bodybytes, &host)
	if err != nil {
		c.jsonError(err, w)
		return
	}
	host.ID = 1

	err = c.db.Save(&host).Error
	if err != nil {
		err = fmt.Errorf("Failed to persist configuration (%s)", err)
		c.jsonError(err, w)
		return
	}

	w.Write(bodybytes)
}

func (c *Controller) PutDomain(w http.ResponseWriter, r *http.Request) {
	domain := Domain{ID: 1}

	bodybytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		c.jsonError(err, w)
		return
	}

	err = json.Unmarshal(bodybytes, &domain)
	if err != nil {
		c.jsonError(err, w)
		return
	}
	domain.ID = 1

	err = c.db.Save(&domain).Error
	if err != nil {
		err = fmt.Errorf("Failed to persist configuration (%s)", err)
		c.jsonError(err, w)
		return
	}

	w.Write(bodybytes)
}

//
// AfterCommit
//

func (c *Controller) AfterCommit() error {
	return nil
}

//
// File generators
//

// RewriteHostnameFile rewrites the hostname file.
func (c *Controller) RewriteHostnameFile() error {
	contents, err := c.hostnameFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile("/etc/hostname", contents, 0644)
	if err != nil {
		return err
	}

	return nil
}

// RewriteInterfacesFile rewrites the network interfaces configuration file.
func (c *Controller) RewriteInterfacesFile() error {
	str, err := c.interfacesConfigFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(InterfacesFilePath, []byte(str), 0644)
	if err != nil {
		return err
	}

	return nil
}

// RewriteDhClientConf file rewrites the dhclient.conf configuration file.
func (c *Controller) RewriteDhclientConfFile() error {
	str, err := c.dhclientConfFileContents()
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(DhclientConfFilePath, []byte(str), 0644)
	if err != nil {
		return err
	}

	return nil
}

// returns contents of the hostname file.
func (c *Controller) hostnameFileContents() ([]byte, error) {
	host := Hostname{}

	err := c.db.First(&host, 1).Error
	if err != nil {
		return nil, err
	}

	return []byte(host.Hostname + "\n"), nil
}

func (c *Controller) interfacesConfigFileContents() ([]byte, error) {
	contents := bytes.Buffer{}

	ifaces := []InterfaceConfig{}
	err := c.db.Find(&ifaces).Error
	if err != nil {
		return contents.Bytes(), err
	}

	// Banner
	contents.WriteString("# This file is AUTOGENERATED.\n")
	contents.WriteString("#\n\n")
	// static section for 'lo'
	contents.WriteString("auto lo\n")
	contents.WriteString("iface lo inet loopback\n\n")

	for _, iface := range ifaces {
		contents.WriteString(c.interfacesConfigFileSection(iface))
		contents.WriteString("\n")
	}

	return contents.Bytes(), nil
}

// returns a section of the interfaces config file that configures the specified nic.
func (c *Controller) interfacesConfigFileSection(iface InterfaceConfig) string {
	contents := bytes.Buffer{}

	// per the docs, err is always nil
	contents.WriteString("auto " + iface.Name + "\n")
	contents.WriteString("iface " + iface.Name + " inet " + iface.Mode + "\n")
	if iface.Mode == ModeStatic {
		contents.WriteString("address " + iface.Address + "\n")
		contents.WriteString("netmask " + iface.Netmask + "\n")
		contents.WriteString("gateway " + iface.Gateway + "\n")
	}

	return string(contents.Bytes())
}

// returns contents of the dhclient.conf file
func (c *Controller) dhclientConfFileContents() ([]byte, error) {
	ret := bytes.Buffer{}

	headerLines := []string{
		"# This file is autogenerated. Do not edit this file.",
		"# Your changes will be overwritten.",
		"#",
		"",
		"option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;",
		"",
	}

	globalOptions := []string{
		"# backoff-cutoff 2;",
		"# initial-interval 1;",
		"# link-timeout 10;",
		"# reboot 0;",
		"# retry 10;",
		"# select-timeout 0;",
		"# timeout 30;",
		"",
	}

	// Add header lines
	for _, h := range headerLines {
		ret.WriteString(h)
		ret.WriteString("\n")
	}

	// Add global options
	for _, g := range globalOptions {
		ret.WriteString(g)
		ret.WriteString("\n")
	}

	// Add interface specific options
	ifaces := []InterfaceConfig{}
	c.db.Where(InterfaceConfig{Mode: ModeDHCP}).Find(&ifaces)
	for _, iface := range ifaces {
		if str, err := c.dhconfFileSection(iface); err != nil {
			fmt.Errorf("ERROR:", err)
			// TODO: LOG
			return []byte{}, err
		} else {
			ret.WriteString(str)
		}
	}

	return ret.Bytes(), nil
}

func (c *Controller) dhconfFileSection(iface InterfaceConfig) (string, error) {
	var (
		ret         = bytes.Buffer{}
		dhcpProfile = DHCPProfile{}

		err error
	)

	err = c.db.First(&dhcpProfile, iface.DHCPProfileID).Error
	if err != nil {
		return "", err
	}

	sectionForSlice := func(indent int, clause string, elems []string) string {
		var (
			lines     = []string{}
			indentStr = strings.Repeat(" ", indent)
			chunks    = chunkSlice(elems, 3)
		)
		for _, chunk := range chunks {
			lines = append(lines, strings.Join(chunk, ", "))
		}
		return indentStr + clause + " " +
			strings.Join(lines, "\n"+indentStr+strings.Repeat(" ", len(clause)+1)) + ";\n"
	}

	sectionForMap := func(indent int, clause string, elems map[string]string) string {
		var (
			retbuf    = bytes.Buffer{}
			indentStr = strings.Repeat(" ", indent)
		)

		for k, v := range elems {
			if len(clause) > 0 {
				retbuf.WriteString(fmt.Sprintf("%s%s %s %s;\n", indentStr, clause, k, v))
			} else {
				retbuf.WriteString(fmt.Sprintf("%s%s %s;\n", indentStr, k, v))
			}
		}
		return string(retbuf.Bytes())
	}

	decodeMap := func(ser string) map[string]string {
		retmap := make(map[string]string)
		if len(ser) <= 0 {
			return retmap
		}
		err := json.Unmarshal([]byte(ser), &retmap)
		if err != nil {
			// TODO: log
			fmt.Println("ERROR (", ser, "):", err)
		}
		return retmap
	}

	decodeSlice := func(ser string) []string {
		ret := []string{}
		if len(ser) <= 0 {
			return ret
		}
		err := json.Unmarshal([]byte(ser), &ret)
		if err != nil {
			// TODO: log
			fmt.Println("ERROR (", ser, "):", err)
		}
		return ret
	}

	ret.WriteString(fmt.Sprintf("interface %s {\n", iface.Name))

	// TODO: handle the 'special' HostNameMode and DomainNameMode flags which allow the user to
	// easily specify whether to override the hostname and domain name returned by the server.

	// Timing options are not 'named'
	ret.WriteString(sectionForMap(2, "", decodeMap(dhcpProfile.TimingOptions)))
	ret.WriteString(sectionForMap(2, "send", decodeMap(dhcpProfile.SendOptions)))
	ret.WriteString(sectionForSlice(2, "request", decodeSlice(dhcpProfile.RequestOptions)))
	ret.WriteString(sectionForSlice(2, "require", decodeSlice(dhcpProfile.RequireOptions)))

	// Not configurable yet (see models.go)
	//ret.WriteString(sectionForMap(2, "append", decodeMap(dhcpProfile.AppendOptions)))
	//ret.WriteString(sectionForMap(2, "prepend", decodeMap(dhcpProfile.PrependOptions)))
	//ret.WriteString(sectionForMap(2, "supersede", decodeMap(dhcpProfile.SupersedeOptions)))

	ret.WriteString("}\n")

	return string(ret.Bytes()), nil
}

//
// Helpers
//

func (c *Controller) jsonError(err error, w http.ResponseWriter) {
	// TODO: switch on err type
	w.WriteHeader(http.StatusInternalServerError)
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(fmt.Sprintf("{\"error\": \"%s\"}", err.Error())))
}

func chunkSlice(s []string, chunkSize int) (ret [][]string) {
	if chunkSize >= len(s) {
		return append(ret, s)
	}

	start := 0
	end := 0

	for {
		start = end
		end = start + chunkSize

		if end >= len(s) {
			ret = append(ret, s[start:])
			return
		}

		ret = append(ret, s[start:end])
	}

	return
}
